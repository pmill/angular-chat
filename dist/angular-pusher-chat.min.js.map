{"version":3,"sources":["pusher-angular.js","module.js","services/chatroom.js","services/pusher.js","directives/lobby.js","templates.js"],"names":["angular","module","factory","$rootScope","$channel","$connection","PusherAngular","pusherClient","this","_assertValidClient","client","connection","channels","prototype","subscribe","channelName","channel","undefined","unsubscribe","bind","eventName","callback","context","invokeDigest","skipDigest","isDefined","decoratedCallback","data","$digest","bind_all","unbind","disconnect","allChannels","isObject","Error","$members","checkPresenceOrPrivateChannel","indexOf","baseChannel","$pusherClient","_assertValidChannel","name","members","trigger","obj","baseMembers","self","_assertValidMembers","me","count","member","info","id","toString","get","each","baseConnection","baseClient","_assertValidConnection","Service","PusherService","connectToRoom","userDetails","currentUser","then","send","sendMessage","message","sendUserDetails","onChatCreated","event","onMessageReceived","onUserJoined","onUserDetailsReceived","startChatWithUser","userId","createRoomChannelName","userIds","sort","hashCode","join","s","split","reduce","a","b","charCodeAt","$inject","$pusher","$q","pusherConfig","connect","console","log","Pusher","apiKey","pusher","resolve","reject","payload","Directive","restrict","scope","user","templateUrl","replace","controller","Controller","controllerAs","bindToController","$scope","ChatRoomService","activate","vm","userDetailsReceived","chatCreated","users","chats","push","directive","run","$templateCache","put"],"mappings":"AAAA,YAEAA,SAAAC,OAAA,qBAEAC,QAAA,WAAA,aAAA,WAAA,cACA,SAAAC,EAAAC,EAAAC,GAEA,QAAAC,GAAAC,GACA,MAAAC,gBAAAF,IAIAE,KAAAC,mBAAAF,GACAC,KAAAE,OAAAH,EACAC,KAAAG,WAAAN,EAAAE,EAAAI,WAAAJ,QACAC,KAAAI,cANA,GAAAN,GAAAC,GAiIA,MAxHAD,GAAAO,WAQAC,UAAA,SAAAC,GACA,GAAAC,GAAAR,KAAAE,OAAAM,QAAAD,EAMA,OALAE,UAAAD,IACAA,EAAAR,KAAAE,OAAAI,UAAAC,IAEAC,EAAAZ,EAAAY,EAAAR,MACAA,KAAAI,SAAAG,GAAAC,EACAA,GASAE,YAAA,SAAAH,GACAP,KAAAE,OAAAM,QAAAD,KACAP,KAAAE,OAAAQ,YAAAH,GACAP,KAAAI,SAAAG,UAAAP,MAAAI,SAAAG,KAcAI,KAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAAxB,QAAAyB,UAAAF,KAAAA,EACAG,EAAA,SAAAC,GACAN,EAAAM,GACAH,GAAArB,EAAAyB,UAGA,OADApB,MAAAE,OAAAS,KAAAC,EAAAM,EAAAJ,GACAI,GASAG,SAAA,SAAAR,EAAAE,GACA,GAAAC,GAAAxB,QAAAyB,UAAAF,KAAAA,CACAf,MAAAE,OAAAmB,SAAA,SAAAT,EAAAO,GACAN,EAAAD,EAAAO,GACAH,GAAArB,EAAAyB,aAWAE,OAAA,SAAAV,EAAAM,EAAAJ,GACAd,KAAAE,OAAAoB,OAAAV,EAAAM,EAAAJ,IAOAS,WAAA,WACAvB,KAAAE,OAAAqB,cAUAf,QAAA,SAAAD,GACA,MAAAP,MAAAI,SAAAG,IASAiB,YAAA,WACA,MAAAxB,MAAAI,UASAH,mBAAA,SAAAF,GACA,IAAAP,QAAAiC,SAAA1B,KACAP,QAAAiC,SAAA1B,EAAAI,aACA,kBAAAJ,GAAA,QACA,KAAA,IAAA2B,OAAA,kCAKA5B,KAIAJ,QAAA,YAAA,aAAA,WACA,SAAAC,EAAAgC,GAEA,QAAAC,GAAArB,GACA,GAAA,IAAAA,EAAAsB,QAAA,cAAA,IAAAtB,EAAAsB,QAAA,YACA,KAAA,IAAAH,OAAA,wCAIA,QAAA9B,GAAAkC,EAAAC,GACA,MAAA/B,gBAAAJ,IAIAI,KAAAgC,oBAAAF,GACA9B,KAAA8B,YAAAA,EACA9B,KAAAE,OAAA6B,EACA/B,KAAAiC,KAAAH,EAAAG,UAEA,IAAAH,EAAAG,KAAAJ,QAAA,YACA7B,KAAAkC,QAAA,WAAA,KAAA,IAAAR,OAAA,qDAEA1B,KAAAkC,QAAAP,EAAAG,EAAAI,QAAAJ,KAXA,GAAAlC,GAAAkC,EAAAC,GAyFA,MA1EAnC,GAAAS,WAUAM,KAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAAxB,QAAAyB,UAAAF,KAAAA,EACAG,EAAA,SAAAC,GACAN,EAAAM,GACAH,GAAArB,EAAAyB,UAGA,OADApB,MAAA8B,YAAAnB,KAAAC,EAAAM,EAAAJ,GACAI,GAUAI,OAAA,SAAAV,EAAAM,EAAAJ,GACAd,KAAA8B,YAAAR,OAAAV,EAAAM,EAAAJ,IASAO,SAAA,SAAAR,EAAAE,GACA,GAAAC,GAAAxB,QAAAyB,UAAAF,KAAAA,CACAf,MAAA8B,YAAAT,SAAA,SAAAT,EAAAO,GACAN,EAAAD,EAAAO,GACAH,GAAArB,EAAAyB,aAaAe,QAAA,SAAAvB,EAAAwB,GAEA,GADAR,EAAA5B,KAAAiC,MACA,IAAArB,EAAAiB,QAAA,WAAA,KAAA,IAAAH,OAAA,uCACA,OAAA1B,MAAA8B,YAAAK,QAAAvB,EAAAwB,IASAJ,oBAAA,SAAAF,GACA,IAAAtC,QAAAiC,SAAAK,IACA,gBAAAA,GAAA,KACA,KAAA,IAAAJ,OAAA,mCAKA9B,KAIAF,QAAA,YAAA,aACA,SAAAC,GAEA,QAAAgC,GAAAU,EAAAP,GACA,KAAA9B,eAAA2B,IACA,MAAA,IAAAA,GAAAU,EAAAP,EAEA,IAAAQ,GAAAtC,IAEAA,MAAAuC,oBAAAF,GACArC,KAAAqC,YAAAA,EACArC,KAAA8B,YAAAA,EACA9B,KAAAwC,MACAxC,KAAAyC,MAAA,EACAzC,KAAAkC,WAEAJ,EAAAnB,KAAA,gCAAA,SAAAuB,GACAI,EAAAE,GAAAN,EAAAM,GACAF,EAAAG,MAAAP,EAAAO,MACAH,EAAAJ,QAAAA,EAAAA,QACAvC,EAAAyB,YAGAU,EAAAnB,KAAA,sBAAA,SAAA+B,GACAJ,EAAAG,QACAC,EAAAC,KACAL,EAAAJ,QAAAQ,EAAAE,GAAAC,YAAAH,EAAAC,KAEAL,EAAAJ,QAAAQ,EAAAE,GAAAC,YAAA,KAEAlD,EAAAyB,YAGAU,EAAAnB,KAAA,wBAAA,SAAA+B,GACAJ,EAAAG,cACAH,GAAAJ,QAAAQ,EAAAE,GAAAC,YACAlD,EAAAyB,YAyCA,MArCAO,GAAAtB,WAOAyC,IAAA,SAAAF,GACA,MAAA5C,MAAAqC,YAAAS,IAAAF,IAQAG,KAAA,SAAAlC,GACAb,KAAAqC,YAAAU,KAAA,SAAAL,GACA7B,EAAA6B,GACA/C,EAAAyB,aAUAmB,oBAAA,SAAAF,GACA,IAAA7C,QAAAiC,SAAAY,IACA,gBAAAA,GAAA,GACA,KAAA,IAAAX,OAAA,2CAKAC,KAIAjC,QAAA,eAAA,aACA,SAAAC,GAEA,QAAAE,GAAAmD,EAAAC,GACA,MAAAjD,gBAAAH,IAIAG,KAAAkD,uBAAAF,GACAhD,KAAAgD,eAAAA,OACAhD,KAAAiD,WAAAA,IALA,GAAApD,GAAAmD,EAAAC,GAoDA,MA5CApD,GAAAQ,WASAM,KAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAAxB,QAAAyB,UAAAF,KAAAA,CACAf,MAAAgD,eAAArC,KAAAC,EAAA,SAAAO,GACAN,EAAAM,GACAH,GAAArB,EAAAyB,WACAN,IASAO,SAAA,SAAAR,EAAAE,GACA,GAAAC,GAAAxB,QAAAyB,UAAAF,KAAAA,CACAf,MAAAgD,eAAA3B,SAAA,SAAAT,EAAAO,GACAN,EAAAD,EAAAO,GACAH,GAAArB,EAAAyB,aAUA8B,uBAAA,SAAAF,GACA,IAAAxD,QAAAiC,SAAAuB,GACA,KAAA,IAAAtB,OAAA,sCAKA7B,KChYA,WAGAL,QACAC,OAAA,uBAAA,sBCJA,WASA,QAAA0D,GAAAC,GAeA,QAAAC,GAAA7C,EAAA8C,GAIA,MAHA/C,GAAAC,EACA+C,EAAAD,EAEAF,EAAA9C,UAAAC,GAAAiD,KAAA,WACAJ,EAAAK,KAAAlD,EAAA,iBAAAgD,KAIA,QAAAG,GAAAC,GACA,MAAAP,GAAAK,KAAAlD,EAAA,mBAAAoD,GAGA,QAAAC,KACA,MAAAR,GAAAK,KAAAlD,EAAA,eAAAgD,GAGA,QAAAM,KACA,MAAAT,GAAAU,MAAAvD,EAAA,gBAGA,QAAAwD,KACA,MAAAX,GAAAU,MAAAvD,EAAA,oBAGA,QAAAyD,KACA,MAAAZ,GAAAU,MAAAvD,EAAA,kBAGA,QAAA0D,KACA,MAAAb,GAAAU,MAAAvD,EAAA,gBAGA,QAAA2D,GAAAC,GACA,GAAAA,IAAAZ,EAAAX,GACA,KAAA,mCAGA,IAAArC,GAAA6D,GAAAb,EAAAX,GAAAuB,GACAd,GAAA9C,GAAAiD,KAAA,WACA,MAAAJ,GAAAK,KAAAlD,EAAA,eAAAA,KAIA,QAAA6D,GAAAC,GAEA,MADAA,GAAAA,EAAAC,OACA,qBAAAC,EAAAF,EAAAG,KAAA,MAGA,QAAAD,GAAAE,GACA,MAAAA,GAAAC,MAAA,IAAAC,OAAA,SAAAC,EAAAC,GAAA,MAAAD,IAAAA,GAAA,GAAAA,EAAAC,EAAAC,WAAA,GAAAF,EAAAA,GAAA,GAhEA,GAAArB,GAAA,KACAhD,EAAA,IAEA,QACA8C,cAAAA,EACAQ,cAAAA,EACAE,kBAAAA,EACAE,sBAAAA,EACAD,aAAAA,EACAN,YAAAA,EACAE,gBAAAA,EACAM,kBAAAA,GAlBA1E,QACAC,OAAA,uBACAC,QAAA,kBAAAyD,GAEAA,EAAA4B,SAAA,oBCPA,WASA,QAAA5B,GAAA6B,EAAAC,EAAAC,GAWA,QAAAC,KACAC,QAAAC,IAAA,wBACA,IAAAnF,GAAA,GAAAoF,QAAAJ,EAAAK,OAAAL,EACAM,GAAAR,EAAA9E,GAGA,QAAA4D,GAAAvD,EAAAK,GACA,MAAAqE,GAAA,SAAAQ,EAAAC,GACAlF,EAAAD,GAAAI,KAAAC,EAAA,SAAAO,GACAsE,EAAAtE,OAKA,QAAAsC,GAAAlD,EAAAK,EAAA+E,GACAP,QAAAC,IAAA,qBAAA9E,EAAAK,EAAA+E,GACAnF,EAAAD,GAAA4B,QAAA5B,EAAAK,EAAA+E,GAGA,QAAArF,GAAAC,GAMA,MALA6E,SAAAC,IAAA,4BAAA9E,EAAA,MACA,OAAAiF,GACAL,IAGAF,EAAA,SAAAQ,EAAAC,GACA,GAAAlF,GAAAgF,EAAAlF,UAAAC,EAEAC,GAAAG,KAAA,gCAAA,WACA8E,EAAAjF,KAGAA,EAAAG,KAAA,4BAAA,WACA+E,EAAAlF,OAKA,QAAAA,GAAAD,GAEA,MADA6E,SAAAC,IAAA,wBAAA9E,GACAiF,EAAAhF,QAAAD,GAlDA,GAAAiF,GAAA,IAEA,QACAhF,QAAAA,EACA2E,QAAAA,EACArB,MAAAA,EACAL,KAAAA,EACAnD,UAAAA,GAdAd,QACAC,OAAA,uBACAC,QAAA,gBAAAyD,GAEAA,EAAA4B,SAAA,UAAA,KAAA,mBCPA,WAOA,QAAAa,KACA,OACAC,SAAA,IACAC,OACAC,KAAA,KAEAC,YAAA,aACAC,SAAA,EACAC,WAAAC,EACAC,aAAA,KACAC,kBAAA,GAMA,QAAAF,GAAAG,EAAAC,GAUA,QAAAC,KACAD,EAAAlD,cAAA,oBAAAoD,EAAAV,MAAAvC,KAAA,WACA+C,EAAAvC,eAAAR,KAAAkD,GACAH,EAAAtC,wBAAAT,KAAAkD,GACAH,EAAA1C,gBAAAL,KAAAmD,KAIA,QAAAD,GAAApD,GACAmD,EAAAtF,KAAAyF,MAAAtD,EAAAV,IAAAU,EAGA,QAAAqD,GAAApG,GACAkG,EAAAtF,KAAA0F,MAAAC,KAAAvG,GAtBA,GAAAkG,GAAAzG,IAEAyG,GAAAtF,MACAyF,SACAC,UAGAL,IA5BAhH,QACAC,OAAA,uBACAsH,UAAA,cAAAnB,GAgBAO,EAAApB,SAAA,SAAA,sBCrBA,WAAAvF,QAAAC,OAAA,uBAAAuH,KAAA,iBAAA,SAAAC,GAAAA,EAAAC,IAAA,aAAA","file":"angular-pusher-chat.min.js","sourcesContent":["'use strict';\n\nangular.module('pusher-angular', [])\n\n.factory('$pusher', ['$rootScope', '$channel', '$connection',\n  function ($rootScope, $channel, $connection) {\n\n    function PusherAngular (pusherClient) {\n      if (!(this instanceof PusherAngular)) {\n        return new PusherAngular(pusherClient);\n      }\n\n      this._assertValidClient(pusherClient);\n      this.client = pusherClient;\n      this.connection = $connection(pusherClient.connection, pusherClient);\n      this.channels = {};\n    }\n\n    PusherAngular.prototype = {\n      /**\n       * Subscribe the client to the specified channelName and returns the channel object.\n       * {@link https://pusher.com/docs/client_api_guide/client_public_channels#subscribe}\n       *\n       * @param {String} channelName name of the channel\n       * @returns {Object} channel object\n       */\n      subscribe: function (channelName) {\n        var channel = this.client.channel(channelName);\n        if(channel === undefined) {\n          channel = this.client.subscribe(channelName);\n        }\n        channel = $channel(channel, this);\n        this.channels[channelName] = channel;\n        return channel;\n      },\n\n      /**\n       * Unsubscribes the client from the specified channel\n       * {@link https://pusher.com/docs/client_api_guide/client_public_channels#unsubscribe}\n       *\n       * @param {String} channelName name of the channel\n       */\n      unsubscribe: function (channelName) {\n        if (this.client.channel(channelName)) {\n          this.client.unsubscribe(channelName);\n          if (this.channels[channelName]) { delete this.channels[channelName]; }\n        }\n      },\n\n      /**\n       * Binds to global events on the pusher client. You can attach behaviour to these events\n       * regardless of the channel the event is broadcast to.\n       *\n       * @param {String} eventName name of the event you want to bind to\n       * @param {Function|undefined} callback callback that you want called upon the event occurring\n       * @param {Object} context used as the `this` value when calling a handler\n       * @param {boolean} [invokeDigest=true] If set to `false` skips invoking $digest\n       * @returns {Function} the decorated version of the callback provided\n       */\n      bind: function (eventName, callback, context, invokeDigest) {\n        var skipDigest = (angular.isDefined(invokeDigest) && !invokeDigest),\n          decoratedCallback = function (data) {\n            callback(data);\n            if (!skipDigest) $rootScope.$digest();\n          };\n        this.client.bind(eventName, decoratedCallback, context);\n        return decoratedCallback;\n      },\n\n      /**\n       * Binds to all of the global client messages.\n       *\n       * @param {Function|undefined} callback callback that you want called upon a message being received\n       * @param {boolean} [invokeDigest=true] If set to `false` skips invoking $digest\n       */\n      bind_all: function (callback, invokeDigest) {\n        var skipDigest = (angular.isDefined(invokeDigest) && !invokeDigest);\n        this.client.bind_all(function (eventName, data) {\n          callback(eventName, data);\n          if (!skipDigest) $rootScope.$digest();\n        });\n      },\n\n      /**\n       * Unbinds from global events on the pusher client.\n       *\n       * @param {String} eventName name of the event you want to bind from\n       * @param {Function|undefined} decoratedCallback the decorated version of the callback that you want to unbind\n       * @param {Object} context used as the `this` value when calling a handler\n       */\n      unbind: function (eventName, decoratedCallback, context) {\n        this.client.unbind(eventName, decoratedCallback, context);\n      },\n\n      /**\n       * Disconnects the pusher client.\n       * {@link http://pusher.com/docs/client_api_guide/client_connect#disconnecting}\n       */\n      disconnect: function () {\n        this.client.disconnect();\n      },\n\n      /**\n       * Returns a pusher channel object.\n       * {@link https://pusher.com/docs/client_api_guide/client_channels#access}\n       *\n       * @param {String} channelName name of the channel\n       * @returns {Array} channel object\n       */\n      channel: function (channelName) {\n        return this.channels[channelName];\n      },\n\n      /**\n       * Returns a an array of the channels that the client is subscribed to.\n       * {@link https://pusher.com/docs/client_api_guide/client_channels#access}\n       *\n       * @returns {Array} array of subscribed channels\n       */\n      allChannels: function () {\n        return this.channels;\n      },\n\n      /**\n       * Asserts that the $pusher object is being initialised with valid pusherClient.\n       * Throws an error if pusherClient is invalid.\n       *\n       * @param {Object} pusherClient members object from base pusher channel object\n       */\n      _assertValidClient: function (pusherClient) {\n        if (!angular.isObject(pusherClient) ||\n            !angular.isObject(pusherClient.connection) ||\n            typeof(pusherClient.channel) !== 'function') {\n          throw new Error('Invalid Pusher client object');\n        }\n      }\n    };\n\n    return PusherAngular;\n  }\n])\n\n.factory('$channel', ['$rootScope', '$members',\n  function ($rootScope, $members) {\n\n    function checkPresenceOrPrivateChannel (channelName) {\n      if (channelName.indexOf('presence-') == -1 && channelName.indexOf('private-') == -1) {\n        throw new Error('Presence or private channel required');\n      }\n    }\n\n    function $channel (baseChannel, $pusherClient) {\n      if (!(this instanceof $channel)) {\n        return new $channel(baseChannel, $pusherClient);\n      }\n\n      this._assertValidChannel(baseChannel);\n      this.baseChannel = baseChannel;\n      this.client = $pusherClient;\n      this.name = baseChannel.name;\n\n      if (baseChannel.name.indexOf('presence') == -1) {\n        this.members = function () { throw new Error('Members object only exists for presence channels'); }\n      } else {\n        this.members = $members(baseChannel.members, baseChannel);\n      }\n    }\n\n    $channel.prototype = {\n      /**\n       * Binds to the given event name on the channel.\n       *\n       * @param {String} eventName name of the event you want to bind to\n       * @param {Function|undefined} callback callback that you want called upon the event occurring\n       * @param {Object} context used as the `this` value when calling a handler\n       * @param {boolean} [invokeDigest=true] If set to `false` skips invoking $digest\n       * @returns {Function} the decorated version of the callback provided\n       */\n      bind: function (eventName, callback, context, invokeDigest) {\n        var skipDigest = (angular.isDefined(invokeDigest) && !invokeDigest),\n            decoratedCallback = function (data) {\n              callback(data);\n              if (!skipDigest) $rootScope.$digest();\n            };\n        this.baseChannel.bind(eventName, decoratedCallback, context);\n        return decoratedCallback;\n      },\n\n      /**\n       * Unbinds from the given event name on the channel.\n       *\n       * @param {String} eventName name of the event you want to bind from\n       * @param {Function|undefined} decoratedCallback the decorated version of the callback that you want to unbind\n       * @param {Object} context used as the `this` value when calling a handler\n       */\n      unbind: function (eventName, decoratedCallback, context) {\n        this.baseChannel.unbind(eventName, decoratedCallback, context);\n      },\n\n      /**\n       * Binds to all of the channel events.\n       *\n       * @param {Function|undefined} callback callback that you want called upon the event occurring\n       * @param {boolean} [invokeDigest=true] If set to `false` skips invoking $digest\n       */\n      bind_all: function (callback, invokeDigest) {\n        var skipDigest = (angular.isDefined(invokeDigest) && !invokeDigest);\n        this.baseChannel.bind_all(function (eventName, data) {\n          callback(eventName, data);\n          if (!skipDigest) $rootScope.$digest();\n        });\n      },\n\n      /**\n       * Triggers a client event.\n       * {@link https://pusher.com/docs/client_api_guide/client_events#trigger-events}\n       *\n       * @param {String} channelName name of the channel\n       * @param {String} eventName name of the event\n       * @param {Object} obj object that you wish to pass along with your client event\n       * @returns {}\n       */\n      trigger: function (eventName, obj) {\n        checkPresenceOrPrivateChannel(this.name);\n        if (eventName.indexOf('client-') == -1) { throw new Error('Event name requires \\'client-\\' prefix'); }\n        return this.baseChannel.trigger(eventName, obj);\n      },\n\n      /**\n       * Asserts that the $channel object is being initialised with valid baseChannel.\n       * Throws an error if baseChannel is invalid.\n       *\n       * @param {Object} baseChannel channel object from base pusher channel object\n       */\n      _assertValidChannel: function (baseChannel) {\n        if (!angular.isObject(baseChannel) ||\n            typeof(baseChannel.name) !== 'string') {\n          throw new Error('Invalid Pusher channel object');\n        }\n      }\n    };\n\n    return $channel;\n  }\n])\n\n.factory('$members', ['$rootScope',\n  function ($rootScope) {\n\n    function $members (baseMembers, baseChannel) {\n      if (!(this instanceof $members)) {\n        return new $members(baseMembers, baseChannel);\n      }\n      var self = this;\n\n      this._assertValidMembers(baseMembers);\n      this.baseMembers = baseMembers;\n      this.baseChannel = baseChannel;\n      this.me = {};\n      this.count = 0;\n      this.members = {};\n\n      baseChannel.bind('pusher:subscription_succeeded', function (members) {\n        self.me = members.me;\n        self.count = members.count;\n        self.members = members.members;\n        $rootScope.$digest();\n      });\n\n      baseChannel.bind('pusher:member_added', function (member) {\n        self.count++;\n        if (member.info) {\n          self.members[member.id.toString()] = member.info;\n        } else {\n          self.members[member.id.toString()] = null;\n        }\n        $rootScope.$digest();\n      });\n\n      baseChannel.bind('pusher:member_removed', function (member) {\n        self.count--;\n        delete self.members[member.id.toString()];\n        $rootScope.$digest();\n      });\n    }\n\n    $members.prototype = {\n     /**\n      * Returns member's info for given id. Resulting object containts two fields - id and info.\n      *\n      * @param {Number} id user's id\n      * @return {Object} member's info or null\n      */\n      get: function (id) {\n        return this.baseMembers.get(id);\n      },\n\n      /**\n       * Calls back for each member in unspecified order.\n       *\n       * @param {Function} callback callback function\n       */\n      each: function (callback) {\n        this.baseMembers.each(function (member) {\n          callback(member);\n          $rootScope.$digest();\n        });\n      },\n\n      /**\n       * Asserts that the $members object is being initialised with valid baseMembers.\n       * Throws an error if baseMembers is invalid.\n       *\n       * @param {Object} baseMembers members object from base pusher channel object\n       */\n      _assertValidMembers: function (baseMembers) {\n        if (!angular.isObject(baseMembers) ||\n            typeof(baseMembers.me) !== 'object') {\n          throw new Error('Invalid Pusher channel members object');\n        }\n      }\n    };\n\n    return $members;\n  }\n])\n\n.factory('$connection', ['$rootScope',\n  function ($rootScope) {\n\n    function $connection (baseConnection, baseClient) {\n      if (!(this instanceof $connection)) {\n        return new $connection(baseConnection, baseClient);\n      }\n\n      this._assertValidConnection(baseConnection);\n      this.baseConnection = baseConnection;\n      this.baseClient = baseClient;\n    }\n\n    $connection.prototype = {\n      /**\n       * Binds to the given event name on the connection.\n       *\n       * @param {String} eventName name of the event you want to bind to\n       * @param {Function|undefined} callback callback that you want called upon the event occurring\n       * @param {Object} context used as the `this` value when calling a handler\n       * @param {boolean} [invokeDigest=true] If set to `false` skips invoking $digest\n       */\n      bind: function (eventName, callback, context, invokeDigest) {\n        var skipDigest = (angular.isDefined(invokeDigest) && !invokeDigest);\n        this.baseConnection.bind(eventName, function (data) {\n          callback(data);\n          if (!skipDigest) $rootScope.$digest();\n        }, context);\n      },\n\n      /**\n       * Binds to all of the global connection events.\n       *\n       * @param {Function|undefined} callback callback that you want called upon the event occurring\n       * @param {boolean} [invokeDigest=true] If set to `false` skips invoking $digest\n       */\n      bind_all: function (callback, invokeDigest) {\n        var skipDigest = (angular.isDefined(invokeDigest) && !invokeDigest);\n        this.baseConnection.bind_all(function (eventName, data) {\n          callback(eventName, data);\n          if (!skipDigest) $rootScope.$digest();\n        });\n      },\n\n      /**\n       * Asserts that the $connection object is being initialised with valid baseConnection.\n       * Throws an error if baseConnection is invalid.\n       *\n       * @param {Object} baseConnection connection object from base pusher object\n       */\n      _assertValidConnection: function (baseConnection) {\n        if (!angular.isObject(baseConnection)) {\n          throw new Error('Invalid Pusher connection object');\n        }\n      }\n    };\n\n    return $connection;\n  }\n]);\n","(function() {\n  \"use strict\";\n\n  angular\n    .module('angular-pusher-chat', ['pusher-angular']);\n})();","(function() {\n  \"use strict\";\n\n  angular\n    .module('angular-pusher-chat')\n    .factory('ChatRoomService', Service);\n\n  Service.$inject = ['PusherService'];\n\n  function Service(PusherService) {\n    var currentUser = null;\n    var channelName = null;\n\n    return {\n      connectToRoom: connectToRoom,\n      onChatCreated: onChatCreated,\n      onMessageReceived: onMessageReceived,\n      onUserDetailsReceived: onUserDetailsReceived,\n      onUserJoined: onUserJoined,\n      sendMessage: sendMessage,\n      sendUserDetails: sendUserDetails,\n      startChatWithUser: startChatWithUser\n    };\n\n    function connectToRoom(channel, userDetails) {\n      channelName = channel;\n      currentUser = userDetails;\n\n      return PusherService.subscribe(channelName).then(function() {\n        PusherService.send(channelName, 'user.connected', currentUser);\n      });\n    }\n\n    function sendMessage(message) {\n      return PusherService.send(channelName, 'message.received', message);\n    }\n\n    function sendUserDetails() {\n      return PusherService.send(channelName, 'user.details', currentUser);\n    }\n\n    function onChatCreated() {\n      return PusherService.event(channelName, 'chat.created');\n    }\n\n    function onMessageReceived() {\n      return PusherService.event(channelName, 'message.received');\n    }\n\n    function onUserJoined() {\n      return PusherService.event(channelName, 'user.connected');\n    }\n\n    function onUserDetailsReceived() {\n      return PusherService.event(channelName, 'user.details');\n    }\n\n    function startChatWithUser(userId) {\n      if (userId === currentUser.id) {\n        throw \"Can't start a chat with yourself!\";\n      }\n\n      var channelName = createRoomChannelName([currentUser.id, userId]);\n      connectToRoom(channelName).then(function() {\n        return PusherService.send(channelName, 'chat.created', channelName);\n      });\n    }\n\n    function createRoomChannelName(userIds) {\n      userIds = userIds.sort();\n      return 'private-chat-room-' + hashCode(userIds.join('|'));\n    }\n\n    function hashCode(s){\n      return s.split(\"\").reduce(function(a,b){a=((a<<5)-a)+b.charCodeAt(0);return a&a},0);\n    }\n  }\n})();","(function() {\n  \"use strict\";\n\n  angular\n    .module('angular-pusher-chat')\n    .factory('PusherService', Service);\n\n  Service.$inject = ['$pusher', '$q', 'pusherConfig'];\n\n  function Service($pusher, $q, pusherConfig) {\n    var pusher = null;\n\n    return {\n      channel: channel,\n      connect: connect,\n      event: event,\n      send: send,\n      subscribe: subscribe\n    };\n\n    function connect() {\n      console.log('PusherService.connect');\n      var client = new Pusher(pusherConfig.apiKey, pusherConfig);\n      pusher = $pusher(client);\n    }\n\n    function event(channelName, eventName) {\n      return $q(function(resolve, reject) {\n        channel(channelName).bind(eventName, function (data) {\n          resolve(data);\n        });\n      });\n    }\n\n    function send(channelName, eventName, payload) {\n      console.log('PusherService.send', channelName, eventName, payload);\n      channel(channelName).trigger(channelName, eventName, payload);\n    }\n\n    function subscribe(channelName) {\n      console.log('PusherService.subscribe(\\'' + channelName + '\\')');\n      if (pusher === null) {\n        connect();\n      }\n\n      return $q(function(resolve, reject) {\n        var channel = pusher.subscribe(channelName);\n\n        channel.bind('pusher:subscription_succeeded', function () {\n          resolve(channel);\n        });\n\n        channel.bind('pusher:subscription_error', function () {\n          reject(channel);\n        });\n      });\n    }\n\n    function channel(channelName) {\n      console.log('PusherService.channel', channelName);\n      return pusher.channel(channelName);\n    }\n  };\n})();","(function() {\n  \"use strict\";\n\n  angular\n    .module('angular-pusher-chat')\n    .directive('pmChatLobby', Directive);\n\n  function Directive() {\n    return {\n      restrict: 'E',\n      scope: {\n        user: '='\n      },\n      templateUrl: 'lobby.html',\n      replace: true,\n      controller: Controller,\n      controllerAs: 'vm',\n      bindToController: true\n    };\n  }\n\n  Controller.$inject = ['$scope', 'ChatRoomService'];\n\n  function Controller($scope, ChatRoomService) {\n    var vm = this;\n\n    vm.data = {\n      users: {},\n      chats: {}\n    };\n\n    activate();\n\n    function activate() {\n      ChatRoomService.connectToRoom('public-chat-users', vm.user).then(function() {\n        ChatRoomService.onUserJoined().then(userDetailsReceived);\n        ChatRoomService.onUserDetailsReceived().then(userDetailsReceived);\n        ChatRoomService.onChatCreated().then(chatCreated)\n      });\n    }\n\n    function userDetailsReceived(userDetails) {\n      vm.data.users[userDetails.id] = userDetails;\n    }\n\n    function chatCreated(channelName) {\n      vm.data.chats.push(channelName);\n    }\n  }\n})();","(function(){angular.module(\"angular-pusher-chat\").run([\"$templateCache\", function($templateCache) {$templateCache.put(\"lobby.html\",\"<div>\\n    <h1>Lobby</h1>\\n\\n    <ul>\\n        <li ng-repeat=\\\"user in vm.data.users\\\">\\n            {{user}}\\n        </li>\\n    </ul>\\n</div>\");}]);})();"],"sourceRoot":"/source/"}